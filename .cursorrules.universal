# Cursor AI Universal Rules
# ÈÄöÁî® AI Âçè‰ΩúËßÑÂàô - ÂèØÂ∫îÁî®‰∫é‰ªª‰ΩïÈ°πÁõÆ

## üîù HIGHEST PRIORITY RULE

**Communication Style**:
- When proposing solutions or design plans, ALWAYS present them as **human-readable logic and workflow descriptions** first.
- DO NOT immediately write code unless explicitly requested.
- Use clear, structured text with bullet points, diagrams, or step-by-step explanations.
- Only provide code implementations AFTER the user has reviewed and approved the logical design.
- Think: "Explain WHAT and WHY before showing HOW."

## Core Rules

### 1. Security & Configuration Management

**NEVER hardcode sensitive information**:
- API keys, access tokens, or authentication credentials
- Database passwords or connection strings
- Private keys or certificates
- Model names, URLs, or service endpoints

**Best Practices**:
- Use environment variables (`.env` files, add to `.gitignore`)
- Use configuration files (YAML, JSON, TOML)
- Centralize configuration management in a dedicated config module/file
- Support multiple environments (development, testing, production)

### 2. Code Quality Standards

**Logging**:
- Use proper logging libraries (Python: `logging`, JS: `winston/pino`, Java: `log4j`, etc.)
- NEVER use `print()` statements in production code
- Set appropriate log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL)
- Include contextual information (timestamps, module names, request IDs)

**Documentation**:
- ALL public classes, methods, and functions MUST have docstrings
- Use consistent docstring style (Google Style / NumPy Style / JSDoc)
- Include parameter descriptions, return values, and exceptions
- Keep docstrings up-to-date with code changes

**Separation of Concerns**:
- Separate data models from business logic
- Extract configuration from code
- Externalize prompts/templates (for AI projects)
- Avoid "god classes" and overly long functions (Single Responsibility Principle)

### 3. Interaction Protocol

**Before Starting Tasks**:
- For complex tasks or architectural changes, ALWAYS summarize your understanding first
- List key assumptions and ask clarifying questions
- Wait for user confirmation before implementing
- DO NOT guess requirements when uncertain

**During Task Execution**:
- For multi-step tasks (‚â•3 steps), create a TODO checklist
- Update progress in real-time
- Communicate promptly when encountering blockers

**Problem Solving**:
- Analyze root causes BEFORE suggesting code fixes
- Explain the "why" behind your solutions
- Avoid quick patches without understanding the problem

**Version Control Reminders**:
At key milestones (major features, architectural changes, significant refactoring), remind the user to:
- Update version numbers (follow Semantic Versioning)
- Commit changes with descriptive commit messages
- Create tags for release versions

### 4. Documentation Maintenance

**Keep documentation synchronized with code**:
- Architecture changes ‚Üí Update architecture documentation
- API changes ‚Üí Update API documentation
- Workflow changes ‚Üí Update flow diagrams/logic descriptions
- Configuration changes ‚Üí Update README and setup guides

**Core Documentation Files** (create if missing):
- `README.md`: Project overview, quick start guide
- `CONTRIBUTING.md`: Development standards, contribution guidelines
- `ARCHITECTURE.md`: System architecture, design decisions
- `CHANGELOG.md`: Version history

**Documentation Quality**:
- Use clear heading hierarchies
- Provide code examples
- Include diagrams (architecture, flow charts)
- Keep it concise, avoid redundancy

### 5. Development Process

**Before Writing Code**:
- Check if similar components/utilities already exist
- Review existing patterns and conventions in the codebase
- Verify the approach aligns with project architecture

**After Writing Code**:
- Run linters and formatters
- Fix any introduced errors or warnings
- Update relevant tests
- Update documentation if needed

**Code Review Mindset**:
- Write code that's easy to review
- Add comments for complex logic
- Follow existing code style
- Consider maintainability and readability

## Language-Agnostic Best Practices

- **DRY (Don't Repeat Yourself)**: Extract common logic into reusable functions/modules
- **KISS (Keep It Simple, Stupid)**: Prefer simple solutions over clever ones
- **YAGNI (You Aren't Gonna Need It)**: Don't add functionality until it's needed
- **Fail Fast**: Validate inputs early, throw clear errors
- **Immutability**: Prefer immutable data structures when possible
- **Type Safety**: Use type hints/annotations where the language supports them

## Testing Principles (when applicable)

- Write tests for critical business logic
- Use descriptive test names that explain what is being tested
- Follow the AAA pattern: Arrange, Act, Assert
- Keep tests independent and repeatable
- Mock external dependencies

## Git Practices

- Write clear, descriptive commit messages
- Follow conventional commit format (optional but recommended):
  - `feat:` new feature
  - `fix:` bug fix
  - `docs:` documentation changes
  - `refactor:` code refactoring
  - `test:` test additions or changes
- Keep commits focused and atomic
- Never force push to main/master branch

## AI-Specific Guidelines (if applicable)

- Extract ALL prompts to external files (YAML, JSON, or text files)
- Version control prompt templates
- Make prompts configurable with placeholders
- Document prompt engineering decisions
- Test prompts with various inputs before deploying

---

## üìù Customization Notes

The following aspects need to be customized per project:

1. **Project Architecture**: Define your specific architecture pattern (MVC, Clean Architecture, microservices, etc.)
2. **Directory Structure**: Specify where different types of files should be placed
3. **Tech Stack**: Document your language, framework, and tool choices
4. **Code Style**: Link to or define your linting rules and formatting standards
5. **Validation Tools**: List project-specific validation or testing commands

Create a project-specific `.cursorrules` file that extends these universal rules with your custom requirements.

---

**Version**: 1.0
**Last Updated**: 2026-02-07
**Scope**: Universal software development projects
