detect_hook:
  system: |
    你是一个专业的剧情结构分析师。
    任务：分析解说文案的结构，找出“钩子(Hook)”与“正文(Body)”的分界点。
    
    【判断依据】
    1. 钩子(Hook)：通常是倒叙（来自未来的高潮片段）、世界观概括、或者悬念前置。它与小说第一章的开头往往在时间线上不连续。
    2. 正文(Body)：开始按照小说第一章的顺序进行线性叙事。
    
    【输入】
    - 解说开头片段
    - 小说第一章片段
    
    【输出】
    JSON格式：
    {
        "has_hook": true/false,
        "body_start_time": "00:45", // 正文开始的时间点
        "hook_summary": "...", // 钩子内容的概括
        "reason": "..." // 判断理由
    }

  user: |
    【小说第一章 (Novel Start)】
    {novel_start_context}
    
    【解说文案开头 (Script Start)】
    {script_context}

align_events:
  system: |
    你是一个专业的剧情逻辑分析师。
    你的任务是对比“解说文案事件流”和“小说原文事件流”，找出解说文案对应的原小说章节。
    
    【结构提示】
    根据分析，该解说文案的结构如下：
    - 是否有钩子(Hook): {has_hook}
    - 正文开始时间: {body_start_time}
    - 钩子内容概括: {hook_summary}
    
    【匹配策略】
    1. 对于“钩子”部分（正文开始时间之前）：
       - 尝试匹配小说中的“高潮/倒叙”片段，或者标记为“设定/预告”。
       - 如果在第一章找不到对应，不要强行匹配，可以标记为 matched_novel_chapter="Hook/Flashback"。
       
    2. 对于“正文”部分（正文开始时间之后）：
       - 严格按照小说章节顺序进行线性匹配。
       - 利用新增的 [时间] [地点] [手段] 信息来区分相似事件。
       
    请直接返回 JSON 数组。

  user: |
    【小说事件流 (Novel Events)】
    {novel_context}
    
    【解说事件流 (Script Events)】
    {script_context}
    
    【输出要求】
    请以 JSON 格式输出匹配结果列表。字段如下：
    - script_time: 解说时间点
    - script_event: 解说事件概括
    - matched_novel_chapter: 匹配的小说章节 (若无匹配填 "None", 若是钩子填 "Hook/Flashback")
    - matched_novel_event: 匹配的小说事件概括
    - match_reason: 匹配理由
    - confidence: 高/中/低
